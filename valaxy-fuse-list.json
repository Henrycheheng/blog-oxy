[{"title":"数组","tags":["algorithm"],"categories":["algorithm"],"author":"akko","excerpt":"\n## 数组\n\n### 创建\n\n● new Array().fill()\n\n● Array.of()\n\n● const arr: any[] = []\n\n### 增删改查\n\npush pop unsh","link":"/posts/algorithm/array","content":"\n## 数组\n\n### 创建\n\n● new Array().fill()\n\n● Array.of()\n\n● const arr: any[] = []\n\n### 增删改查\n\npush pop unshift shift  splice(第几个位置开始，删除几个，添加的元素)\n排序\nsort (（x,y）=> y - x) 正序\n\n### 合并数组\n\n...\n\n### 遍历\n\n● map：接受一个回调函数，返回新的数组\n\n● filter： 接受一个回调函数，返回符合过滤条件的数组\n\n● some： 接受一个回调函数，只要有一个满足的元素，返回true/或者false\n\n● every： 接受一个回调函数，必须所有的元素都满足条件，才返回true\n\n● reduce:\n\n    ○ 接受一个2个参数，第一个初始化的值，第二个是一个回调函数，回调函数最多接受4个参数\n\n    ○ pre,next,index,arr\n\n● foreach\n\n    ○ 通常无法打断，不过可以throw new Error()\n\n● for...in/for of\n\n    ○ 优点可以break/continue\n\n### 类数组转化\n\n● Array.from\n\n### 迭代器\n\n```ts\nconst arr  = [1,2,3]\nlet ite = arr[Symbol.iterator]()\nconsole.log(ite.next()) // 即可拿到迭代器对象\n// 或者for...of\nfor (let i of arr) {\n console.log(i)\n}\n\nconsole.log(arr.entries()) // 迭代器对象\n```\n\n### 数组的特殊遍历\n\n```ts\nconst arr = [1,2,3]\narr.keys（） // 拿到数组/对象的所有的key形成一个数组\narr.values() // 拿到数组/对象的所有values形成一个数组\narr.entries() // 拿到数组的key/values形成多个数组 然后遍历即可获得数组的每一项的key-value映射\n```\n\n### 搜索\n\n● indexOf,includes 判断某个元素是否在数组里\n\n● find,findLast , 接受回调函数，返回第一个/最后一个满足的元素\n\n● findIndex,findLastIndex 接受一个回调函数，返回第一个/最后一个满足元素的索引\n\n```js\nconst arr = [1,2,3]\nconst res = arr.find(item=>item>1) // 1\n```\n\n### 二维数组\n\n创建\n\n```js\nconst arr = [\n [1,2,3],\n [2,3,4],\n]\n\n// 遍历 双重for循环\nfor(let i =0; i<arr.length; i++) {\n console.log(`第${i+1}个数组`)\n for(let j=0; j<arr[i].length; j++){\n  console.log(arr[i][j])\n }\n}\n```\n"},{"title":"stack","tags":["algorithm"],"categories":["algorithm"],"author":"akko","excerpt":"\n## stack\n\n● 结尾删除和添加\n\n● 后入先出\n\n## 封装\n\n- #item表示是当前类的私有属性。\n\n```ts\n// push 一个元素到栈顶\n// pop 出栈\n// peek 返回","link":"/posts/algorithm/stack","content":"\n## stack\n\n● 结尾删除和添加\n\n● 后入先出\n\n## 封装\n\n- #item表示是当前类的私有属性。\n\n```ts\n// push 一个元素到栈顶\n// pop 出栈\n// peek 返回栈顶\n\n// isEmpty()\n// clear()\n// size()\n// toString()\n\nclass Stack {\n #items = []\n\n pop() {\n  return this.#items.pop()\n }\n\n push(data){\n  this.#items.push(data)\n }\n\n peek(){\n  return this.#items.at(-1)\n }\n\n size(){\n  return this.#items.length\n }\n\n isEmpty(){\n  if(this.size() === 0) return true\n  return false\n }\n\n clear(){\n  return this.#items = []\n }\n\n toString() {\n  return this.#items.join(',')\n }\n}\n\nlet stack = new Stack()\n```\n\n## 栈的使用\n\n```ts\nfunction convert(decNumber,convertNum){\n let stack = new Stack()\n let number = decNumber\n let string = '' // 要输出的string\n\n while(number>0){\n  stack.push(number%convertNum) // 余数推入栈\n  number = Math.floor(number/convertNum) // 商进行下一次循环\n }\n\n while(!stack.isEmpty()){\n  string+=stack.pop()\n }\n}\n\nconvert(50,2) // 将一个数字转化成2进制\n```\n"},{"title":"css面试相关","tags":["css"],"categories":["css"],"author":"akko","excerpt":"\n### 01.如果实现一个 css 平移的动画，使用 transform 和改变 left 值有什么区别？\n\n[回流和重绘](<https://juejin.cn/post/701318711284","link":"/posts/css/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98","content":"\n### 01.如果实现一个 css 平移的动画，使用 transform 和改变 left 值有什么区别？\n\n[回流和重绘](<https://juejin.cn/post/7013187112849637407#heading-0>)\n"},{"title":"cocos开发mmoact游戏技术预研","tags":["game"],"categories":["game"],"author":"akko","excerpt":"\n## 游戏引擎\n\n- Cocos 引擎可以用于构建游戏的基础架构和实现游戏逻辑，但可能需要对引擎进行扩展以满足大规模 回合制即时策略 游戏的要求。\n- 了解引擎的内部机制、优化性能以及适当的使用方法","link":"/posts/game/cocos%E5%BC%80%E5%8F%91mmoact%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94","content":"\n## 游戏引擎\n\n- Cocos 引擎可以用于构建游戏的基础架构和实现游戏逻辑，但可能需要对引擎进行扩展以满足大规模 回合制即时策略 游戏的要求。\n- 了解引擎的内部机制、优化性能以及适当的使用方法是必要的。\n\n## 服务器端\n\n开发 MMOACT 游戏需要强大的服务器端基础设施来处理大量玩家的交互和游戏逻辑。\n\n- 比如使用 Node.js(Nest) 或其他语言来实现游戏服务器，并使用数据库（adminMongo等）来存储玩家数据。\n- 深入了解网络编程和安全性是必要的。安全措施包括数据加密、防作弊机制和用户身份验证。\n\n## 网络编程\n\n大型 MMOACT 游戏需要高效的网络通信来处理多个玩家之间的实时互动。需要深入了解网络编程，包括实现实时同步、虚拟化网络空间、消息传递和安全性等方面。\n\n## 游戏设计与开发\n\n- 游戏需要深入了解游戏设计和开发流程。这涉及到角色设计、关卡设计、动作和技能设计、游戏世界构建等方面。\n- 在开发过程中，持续优化游戏内容和玩法以提供更好的用户体验是必要的。\n\n## 图形和动画\n\n- Cocos 引擎提供了图形渲染和动画功能，但可能需要深入了解游戏中复杂的角色动画、特效和视觉效果的制作。\nstable diffsion\n\n## 安全性\n\n网络游戏通常会面临安全风险，比如作弊和数据泄露。需要实施安全措施来保护玩家数据和游戏系统的安全性。\n\n## 运维和扩展\n\n在游戏发布后，需要考虑运维和游戏的持续发展。这包括服务器的维护、性能优化、故障排除以及对游戏内容的持续更新和扩展。\n"},{"title":"初识sonicpi","tags":["music","game"],"categories":["music"],"author":"akko","excerpt":"\n\n### 演奏一段旋律\n\n输入以下内容并点击运行\n\n```\nplay 60\nplay 67\nplay 69\n```\n\n### 休止符\n\n听起来不成调，是吧？输入进Sonic Pi的所有音符都是即刻运","link":"/posts/music/01%E5%88%9D%E8%AF%86sonicpi","content":"\n\n### 演奏一段旋律\n\n输入以下内容并点击运行\n\n```\nplay 60\nplay 67\nplay 69\n```\n\n### 休止符\n\n听起来不成调，是吧？输入进Sonic Pi的所有音符都是即刻运行的（这也是和弦的创作基础），并不是有序演奏。 如果你想让Sonic Pi有序演奏，就要让软件适时停顿。在每个音符下面输入一行 sleep 1 ，如下图所示：\n```\nplay 60\nsleep 1\nplay 67\nsleep 1\nplay 69\nsleep 1\n```\nsleep 1指令代表休止一拍。你可以自行改成其他数值，数值越低，音符间休止时长越短，反之亦然。以下是五线谱和Sonic Pi指令对照表：\n\n![alt text](./image.png)\n\n如前所述，MIDI可以用0到127(67, 80, 22) 的自然数或者音符 (:G4, :Ab5, :Bb)来编曲。 下图是一个MIDI数值和音符的对照表。\n\n![alt text](./image-1.png)\n\n### 谱写一段旋律\n用C大调音阶(72, 74, 76, 77, 79, 81, 83 要么 :C5 :D5 :E5 :F5 :G5 :A5 :B5) 来谱写一段旋律。用 sleep 指令配合不同数值来区别韵律。\n\n- 在代码开端使用 use_bpm 指令可以界定节奏快慢。\n\n- BPM是每分钟节拍(Beats Per Minute)的缩写。\n```\nuse_bpm 120\n\nplay 72\nsleep 0.25\nplay 76\nsleep 0.25\nplay 76\nsleep 0.25\nplay 72\nsleep 0.5\nplay 83\nsleep 0.25\nplay 74\nsleep 0.25\nplay 83\nsleep 0.25\nplay 79\nplay 84\n```\n开始你的个人创作吧！\n"},{"title":"02.乐理","tags":["music","game"],"categories":["music"],"author":"akko","excerpt":"\n\n### 不错，你已经写出一段优美的旋律了。\n\n我们接下来试试反复或反复部分旋律若干次。尽管你可以用复制粘贴的方式，但是反复次数太多还是很麻烦的。好在我们还能用 repetition指令。这个神奇的","link":"/posts/music/02%E4%B9%90%E7%90%86","content":"\n\n### 不错，你已经写出一段优美的旋律了。\n\n我们接下来试试反复或反复部分旋律若干次。尽管你可以用复制粘贴的方式，但是反复次数太多还是很麻烦的。好在我们还能用 repetition指令。这个神奇的单词在计算机术语中叫做“迭代”，就是重复的意思。\n\n在旋律开端输入2.times do ，末尾输入 end 来结束旋律。（音符使用了音名为了方便举例，你也可以输入MIDI数值。）\n\n\n```\n2.times do\n  play :c4\n  sleep 0.5\n  play :d4\n  sleep 0.5\n  play :e4\n  sleep 0.5\n  play :c4\n  sleep 0.5\nend\n```\n\n除了输入2.times do，你可以自行决定重复次数。比如4.times do或99.times do。\n\n有必要的话你也可以在重复指令里面嵌套重复。\n\n```\n4.times do\n  4.times do\n    play :c4\n    sleep 0.25\n  end\n  play :d4\n  sleep 0.5\n  play :f4\n  sleep 0.5\nend\n```\n"},{"title":"03.hithat","tags":["music","game"],"categories":["music"],"author":"akko","excerpt":"\n### 鼓点\n\n我们来看一下如何编写一段包含大鼓，小鼓和踩镲的鼓点。你能学会两点：live_loop指令和采样。\n\n在空白的编程面板创建一个名为:drums的live_loop指令。你可以随意命名，","link":"/posts/music/03hithat","content":"\n### 鼓点\n\n我们来看一下如何编写一段包含大鼓，小鼓和踩镲的鼓点。你能学会两点：live_loop指令和采样。\n\n在空白的编程面板创建一个名为:drums的live_loop指令。你可以随意命名，名字只是为了快速辨别循环了什么内容。live_loop是一个可以跟其他多个live_loop同步的无限循环（一个live_loop至少要有一个sleep指令）：\n```\nlive_loop :drums do\n  sample :drum_heavy_kick\n  sleep 1\nend\n```\n\n点击run来听听你的第一个live_loop演奏的每一个漂亮的节拍。\n\n我们在1、3行用大鼓，2、4行用小鼓做一个简单的基调强节奏。不同于演奏音符，你会触发采样。就像输入sample :sample_name一样简单。下面是鼓点的举例。\n\n```\nuse_bpm 100\n\nlive_loop :drums do\n  sample :drum_heavy_kick\n  sleep 1\n  sample :drum_snare_hard\n  sleep 1\n  sample :drum_heavy_kick\n  sleep 1\n  sample :drum_snare_hard\n  sleep 1\nend\n```\n\n这就是个稳定的基调强节奏。鼓点循环从大鼓开始，小鼓在第二拍，第三拍还是大鼓，第四拍小鼓。然后循环又开始了：\n\n![alt text](./image-2.png)\n\n现在试着变一下节奏（use_bpm后的数字）然后用采样演奏一下。在输入采样名称的时候，浏览一下各种自动完成的采样的特性。试试不同的采样然后感受一下他们听起来都什么样。需要留意的是，你想变换声音的时候并不需要点击终止按钮，改写代码再重新点击运行，声音就会在下一个循环自动变换而不会错过任何一个节拍！\n\n### 加入踩镲\n现在加一个踩镲。创建一个名为hihat的live_loop然后加入你的hi-hat采样。 你可以直接做这样的八分之一或者十六分之一的音符（这个就是十六分之一）\n\n```\nlive_loop :hihat do\n  sample :drum_cymbal_closed\n  sleep 0.25\nend\n```\n\n但是不用这么死板，也可以做得像这样放一点：\n```\nlive_loop :hihat do\n  sample :drum_cymbal_closed\n  sleep 0.25\n  sample :drum_cymbal_pedal\n  sleep 1\nend\n```\n多重节奏模式最开始是一个“错误”。这个循环时长1.25拍 而不是一拍。但是听起来很带感！所以记得多犯点错，也就能发现点没想刻意发现的结果。\n\n现在歌曲就听起来像这样了\n```\nuse_bpm 100\n\nlive_loop :drums do\n  sample :drum_heavy_kick\n  sleep 1\n  sample :drum_snare_hard\n  sleep 1\n  sample :drum_heavy_kick\n  sleep 1\n  sample :drum_snare_hard\n  sleep 1\nend\n\nlive_loop :hihat do\n  sample :drum_cymbal_closed\n  sleep 0.25\n  sample :drum_cymbal_pedal\n  sleep 1\nend\n```\n"},{"title":"记录一次react面试","tags":["react面试"],"categories":["react"],"author":"akko","excerpt":"\n#### 1.setState是同步还是异步的\n\n在React中，setState通常是异步的。当你调用setState时，React会将状态更新放入队列，然后在稍后的某个时间点才会执行实际的状态更","link":"/posts/react/interview","content":"\n#### 1.setState是同步还是异步的\n\n在React中，setState通常是异步的。当你调用setState时，React会将状态更新放入队列，然后在稍后的某个时间点才会执行实际的状态更新。这是出于性能和优化的考虑，因为React会批量处理状态更新以最小化DOM操作，从而提高性能。\n\n这意味着在调用setState之后，你不能立即依赖于状态已经被更新。如果你需要在状态更新后执行某些操作，可以使用setState的第二个参数，它是一个回调函数，会在状态更新完成后被调用，例如：\n\n```javascript\n\nthis.setState({ count: this.state.count + 1 }, () => {\n  // 在这个回调函数中可以访问到更新后的状态\n  console.log(this.state.count);\n});\n```\n\n以下是一些可能导致`setState`同步执行的情况：\n\n1. **在合成事件处理函数中的`setState`**：当`setState`被调用时，React通常会将多个`setState`调用合并成单个更新，以提高性能。然而，在合成事件处理函数中，React不会进行批量处理，因此`setState`可能会同步执行。\n\n```javascript\nbuttonClickHandler() {\n  this.setState({ count: this.state.count + 1 });\n  console.log(this.state.count); // 这里可能是同步的\n}\n```\n\n2. **`setState`的第二个参数**：`setState`的第二个参数是一个回调函数，它会在状态更新完成后被调用。在这个回调函数中，你可以访问到更新后的状态，这是同步的。\n\n```javascript\nthis.setState({ count: this.state.count + 1 }, () => {\n  console.log(this.state.count); // 这里是同步的\n});\n```\n\n在大多数情况下，你应该将`setState`视为异步操作，而且不应该依赖于状态的即时更新。\n\n#### 2.函数组件如何执行卸载\n\n在React中，函数组件卸载的过程是由React自动管理的，无需手动执行。当一个函数组件从DOM中移除时，React会自动触发卸载生命周期方法，主要包括`componentWillUnmount`（在React 16.3之前）和`useEffect`中的清理函数（在React 16.3及以后）。\n\n在函数组件中，你可以使用`useEffect`来模拟类组件的卸载操作。你可以在`useEffect`中返回一个清理函数，它会在组件卸载时执行。例如：\n\n```javascript\nimport React, { useEffect } from 'react';\n\nfunction MyComponent() {\n  // 在这里定义副作用\n  useEffect(() => {\n    // 执行一些操作\n\n    // 返回一个清理函数，会在组件卸载时执行\n    return () => {\n      // 执行卸载时需要的清理操作\n    };\n  }, []); // 空数组作为第二个参数表示只在组件挂载和卸载时执行\n}\n```\n\n当函数组件被卸载时，React会自动调用这个清理函数，你可以在这里进行一些资源释放或取消订阅等操作。这是React函数组件管理生命周期的一种方式，确保在组件卸载时执行必要的清理操作。\n\n#### 3.react类组件的生命周期\n\n在React类组件中，生命周期可以分为三个阶段：挂载、更新和卸载。以下是React类组件的主要生命周期方法：\n\n1. **挂载阶段**：\n\n   - `constructor(props)`: 组件的构造函数，用于初始化状态和绑定事件处理函数。\n   - `static getDerivedStateFromProps(props, state)`: 从属性中派生状态的静态方法（React 16.3+）。\n   - `render()`: 渲染方法，返回虚拟DOM。\n   - `componentDidMount()`: 组件挂载后调用，通常用于发送网络请求或订阅数据。\n\n2. **更新阶段**：\n\n   - `static getDerivedStateFromProps(props, state)`: 更新阶段也可以用来派生状态。\n   - `shouldComponentUpdate(nextProps, nextState)`: 决定是否重新渲染组件，优化性能。\n   - `render()`: 重新渲染组件。\n   - `getSnapshotBeforeUpdate(prevProps, prevState)`: 获取更新前的DOM快照（React 16.3+）。\n   - `componentDidUpdate(prevProps, prevState, snapshot)`: 更新完成后调用，通常用于处理DOM更新之后的操作。\n\n3. **卸载阶段**：\n\n   - `componentWillUnmount()`: 组件卸载前调用，通常用于清理操作、取消订阅或定时器等。\n\n此外，还有一些生命周期方法在React 16.3之前存在，但在后续版本中已被弃用，不推荐使用：\n\n- `componentWillMount()`: 挂载前调用，现在一般用`constructor`替代。\n- `componentWillReceiveProps(nextProps)`: 接收新属性时调用，现在推荐使用`getDerivedStateFromProps`。\n- `componentWillUpdate(nextProps, nextState)`: 更新前调用，现在推荐使用`getSnapshotBeforeUpdate`和`componentDidUpdate`。\n\n需要注意的是，React 16.3之后，生命周期方法的使用方式发生了变化，引入了新的生命周期方法以支持更多的场景。如果你使用React 16.3或更高版本，建议使用新的生命周期方法，如`getDerivedStateFromProps`和`getSnapshotBeforeUpdate`。\n\n#### 4.执行多次事件是如何渲染\n\n最终会渲染一次，会进行合并。\n\n`shouldComponentUpdate` 是 React 类组件中的一个生命周期方法，用于决定组件是否需要重新渲染，从而可以优化性能。当组件的状态或属性发生变化时，React 会调用 `shouldComponentUpdate` 方法，你可以在这个方法中返回 `true` 或 `false` 来告诉 React 是否继续进行渲染。\n\n下面是对 `shouldComponentUpdate` 方法的详细讲解：\n\n1. **作用**：\n   - `shouldComponentUpdate(nextProps, nextState)` 在更新阶段被调用。\n   - 接收两个参数：`nextProps` 表示下一个属性（props），`nextState` 表示下一个状态（state）。\n   - 你可以在这个方法中根据新的属性和状态来判断是否需要重新渲染组件。\n\n2. **返回值**：\n   - 如果 `shouldComponentUpdate` 返回 `true`，组件将会重新渲染。\n   - 如果 `shouldComponentUpdate` 返回 `false`，组件将不会重新渲染，以提高性能。\n\n3. **使用场景**：\n   - 性能优化：`shouldComponentUpdate` 可用于避免不必要的渲染，特别是当你明确知道组件在某些条件下不需要更新时。\n   - 深层次属性比较：你可以在这个方法中比较属性或状态的深层次内容，从而减少不必要的渲染。\n   - 避免子组件的渲染：如果你知道子组件也实现了 `shouldComponentUpdate`，你可以在父组件中使用它来进一步优化性能。\n\n4. **注意事项**：\n   - 调用 `shouldComponentUpdate` 时，不要直接修改组件的状态或属性，这可能导致不稳定的行为。\n   - 如果你不提供 `shouldComponentUpdate` 方法，React 默认会返回 `true`，即每次属性或状态变化都会触发重新渲染。\n\n示例代码：\n\n```javascript\nclass MyComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // 根据条件判断是否需要重新渲染\n    if (this.props.someValue === nextProps.someValue) {\n      return false; // 不重新渲染\n    }\n    return true; // 重新渲染\n  }\n\n  render() {\n    // 渲染组件的内容\n  }\n}\n```\n\n使用 `shouldComponentUpdate` 可以帮助你更精细地控制组件的渲染，以减少不必要的性能开销。\n\n`shouldComponentUpdate` 是一个生命周期方法，用于告诉React是否要重新渲染组件。在React 16.3之后，它并没有被废弃，仍然存在，但是在函数组件中不再可用，因为函数组件没有生命周期方法。\n\n对于类组件，`shouldComponentUpdate` 仍然会被自动调用，以判断是否需要重新渲染组件。这个方法的返回值仍然有效，但不再建议在函数组件中使用。在函数组件中，你可以使用`React.memo`或`PureComponent`（对类组件而言）来达到类似的性能优化目的。而在函数组件中，你可以使用`useMemo`或`useCallback`来控制何时重新计算组件的部分内容。\n\n总之，`shouldComponentUpdate` 仍然是React类组件的一部分，并在适当的情况下使用它可以帮助提高性能，但在函数组件中已经不再适用。\n\n#### 5.foreach/map等方法和for循环相比有什么优缺点\n\n数组的方法循环无法终止单次循环，而for循环可以`break`和单次`continue`。或者`return`.\n终止的方法还有 `||` `default` || `setTimeout`\n\n```javascript\nlet div = document.querySelector('div')\nlet btn = document.querySelector('btn')\n\n    function() {\n      console.log('123')\n    }\n\n    dv.addEventListener('click', function()){\n\n    }\n\n    btn.onclick = function() {\n      dv.removeEventListener('click', function() {\n\n      }\n    }\n```\n\n#### 6.PureComponent和component的区别\n\n`PureComponent` 是 React 中的一个优化工具，是 `React.Component` 的一个变种，用于减少组件重新渲染的频率，以提高性能。它在React中自动执行浅比较（shallow comparison）来检测属性和状态的变化，从而避免不必要的渲染。以下是 `PureComponent` 的详细介绍：\n\n1. **性能优化**：\n   - `PureComponent` 用于性能优化，适用于那些属性和状态变化不频繁的组件。\n   - 与普通的 `React.Component` 不同，`PureComponent` 在 `shouldComponentUpdate` 中执行浅比较，只有在属性或状态发生实际变化时才重新渲染组件。\n\n2. **自动实现的 `shouldComponentUpdate`**：\n   - `PureComponent` 自动实现了 `shouldComponentUpdate` 方法，无需手动编写。\n   - 它会对属性（`props`）和状态（`state`）进行浅比较，以确定是否需要重新渲染组件。\n\n3. **浅比较**：\n   - 在浅比较中，`PureComponent`会比较属性和状态的引用，而不是其内部内容。\n   - 这意味着如果属性或状态中的对象引用没有实际变化，`PureComponent` 将认为它们没有改变，从而跳过重新渲染。\n\n4. **使用场景**：\n   - `PureComponent` 特别适用于那些具有稳定不变属性和状态的组件，或者属性和状态更新频率较低的组件。\n   - 避免在 `PureComponent` 中使用可变数据结构，因为浅比较可能会无法检测到数据结构内部的变化。\n\n示例代码：\n\n```javascript\nimport React, { PureComponent } from 'react';\n\nclass MyPureComponent extends PureComponent {\n  render() {\n    return <div>{this.props.someData}</div>;\n  }\n}\n```\n\n总之，`PureComponent` 是一个有助于减少不必要的渲染的工具，但在使用时需要注意它的适用场景，确保属性和状态的比较满足浅比较的要求，以获得最佳性能。如果你有不稳定或频繁变化的属性和状态，使用 `PureComponent` 可能不会带来明显的性能提升。\n"},{"title":"Reack Hooks小记","tags":["Reack Hooks"],"categories":["react"],"author":"akko","excerpt":"\nReact Hooks 是 React 16.8 版本新增的特性,它允许在函数组件中使用 state 及其他 React 特性,不再必须转换成 class 组件。\nReact Hooks 的主要功能","link":"/posts/react/react-hook","content":"\nReact Hooks 是 React 16.8 版本新增的特性,它允许在函数组件中使用 state 及其他 React 特性,不再必须转换成 class 组件。\nReact Hooks 的主要功能\n\n### 1. useState: 在函数组件中声明状态变量\n\n```tsx\nimport React, { useState } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n### 2. useEffect: 在函数组件各个生命周期执行副作用操作\n\n#### 基本语法\n\n```tsx\nuseEffect(callback, dependencies);\n// callback: 在组件渲染后执行的副作用操作的函数\n// dependencies（可选）: 这是一个数组，它包含影响副作用操作执行的依赖项。\n// 当依赖项发生变化时，副作用操作会被重新执行。\n```\n\n#### 使用方法\n\n```tsx\nimport React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\nuseEffect结合了 class 组件中生命周期函数(componentDidMount、componentDidUpdate 和 componentWillUnmount)的功能\n\n常见的 useEffect 使用方式:\n\n#### 2.1 执行只运行一次的 effect(componentDidMount 等价)\n\n```tsx\nuseEffect(() => {\n  // 数据获取操作\n  fetch('<https://api.example.com/data>')\n    .then(response => response.json())\n    .then(data => {\n      // 更新组件状态\n      setData(data);\n    });\n}, []); // 空数组表示副作用操作只在组件挂载时执行\n```\n\n#### 2.2 根据依赖条件执行 effect(componentDidUpdate 等价)\n\n```tsx\nuseEffect(() => {\n  // 这个副作用操作依赖于count的值\n  document.title = `Count: ${count}`;\n}, [count]); // 依赖项列表中的任何值发生变化，副作用操作将被重新执行。\n```\n\n#### 2.3 清除 effect(componentWillUnmount 等价)\n\n```tsx\nuseEffect(() => {\n  const timer = setInterval(() => {\n    // 定时操作\n  }, 1000);\n  return () => {\n    // 清理操作，在组件卸载时执行\n    clearInterval(timer);\n  };\n}, []);\n```\n\n#### 2.4 多个 useEffect\n\n// 在一个组件中使用多个 `useEffect`，每个 `useEffect` 可以负责不同的副作用操作和依赖项\n\n```tsx\nuseEffect(() => {\n  // 副作用操作 A\n}, [dependencyA]);\n\nuseEffect(() => {\n  // 副作用操作 B\n}, [dependencyB]);\n```\n\n### 3. useContext:用于在函数式组件中访问上下文（context）\n\n#### 3.1 基本语法\n\n```tsx\nconst value = useContext(MyContext);\n// MyContext: 是一个 React 上下文对象，它通常是通过 `React.createContext` 创建的。\n```\n\n#### 3.2 使用方式\n\n例如A、B、C三个组件，逐层嵌套A>B>C\n// MyContext.js\n\n```tsx\nimport { createContext } from 'react';\n\n// 使用createContext建立一个context，并导出\nconst MyContext = createContext();\nexport default MyContext;\n```\n\n#### 3.3 使用改进\n\n//组件A\n\n```tsx\nimport React from \"react\";\nimport B from \"./B\";\nimport MyContext from './MyContext';\n\nfunction App() {\n  const value = 'This is the context value';\n  return (\n    // 传递数据组件里使用Provide包裹着子组件，并且在用value属性来传递数据\n    <MyContext.Provider value={value}>\n      {/*这里可以包含你的组件树*/}\n      <B />\n    </MyContext.Provider>\n  );\n}\nexport default App;\n```\n\n//组件B\n\n```tsx\nimport C from \"./C\";\n\nfunction B() {\n  return (\n    <>\n      <C />\n    </>\n  );\n}\n\nexport default B;\n```\n\n//组件C\n\n```tsx\nimport React from \"react\";\nimport MyContext from './MyContext';\n\nfunction C() {\n  return (\n    // 接受数据的组件导入定义的context使用Consumer来接收,可接收到的是一个函数。\n    <MyContext.Consumer>\n      {(value) => <span>{value}</span>}\n    </MyContext.Consumer>\n  );\n}\n\nexport default C;\n```\n\n但是，当有多个context，在C中使用将会变得很不友好\n\n// myContext2.js\n\n```tsx\nimport { createContext } from 'react';\n\n// 使用createContext建立一个context，并导出\nconst MyContext2 = createContext();\nexport default MyContext2;\n```\n\n//组件A\n\n```tsx\nimport React from \"react\";\nimport B from \"./B\";\nimport MyContext from './MyContext';\nimport MyContext2 from './MyContext2';\n\nfunction App() {\n  return (\n    const value = 'This is the context value';\n    const value2 = 'This is the context2 value';\n\n    <MyContext.Provider value={value}>\n      <MyContext2.Provider value={value2}>\n        <B />\n      </MyContext2.Provider>\n    </MyContext.Provider>\n  );\n}\n\nexport default App;\n```\n\n//组件C\n\n```tsx\nimport React from \"react\";\nimport MyContext from './MyContext';\nimport MyContext2 from './MyContext2';\n\nfunction C() {\n  return (\n    <MyContext.Consumer>\n      {(value) => (\n        <>\n          <span>{value}</span>\n          <MyContext2.Consumer>\n            {(value2) => <span>{value2}</span>}\n          </MyContext2.Consumer>\n        </>\n      )}\n    </MyContext.Consumer>\n  );\n}\n\nexport default C;\n```\n\n此时可以通过useContext来重新获取A组件传递的值\n\n```tsx\n import React from \"react\";\nimport MyContext from './MyContext';\nimport MyContext2 from './MyContext2';\n\nfunction C() {\n  const value = useContext(MyContext);\n  const value2 = useContext(MyContext2);\n\n  return (\n    <>\n      <span>{value}</span>\n      <span>{value2}</span>\n    </>\n  );\n}\nexport default C;\n```\n\n### 4. useReducer:通过 reducer 来管理组件局部状态\n\n#### 4.1 基本用法\n\n```tsx\nconst [state, dispatch] = useReducer(reducer, initialState);\n// reducer函数: `(state, action) => newState` 的纯函数,\n// 用于根据 old state 和 action 返回一个新的 state。\n// initialState: 初始状态的值\n```\n\n#### 4.2 使用方式\n\n```tsx\nimport React, { useReducer } from 'react';\n\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { count: state.count + 1 };\n    case 'DECREMENT':\n      return { count: state.count - 1 };\n    default:\n      return state;\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const increment = () => {\n    dispatch({ type: 'INCREMENT' });\n  };\n\n  const decrement = () => {\n    dispatch({ type: 'DECREMENT' });\n  };\n\n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n}\n```\n\n#### 4.3 示例\n\n使用useReducer代替复杂的state，如果组件层级比较深，需要子组件触发state，可以同时使用useContext传递dispatch\n\n以下是一个简化的购物车示例：\n\n创建一个购物车上下文 CartContext，包含了 cartReducer 和一些自定义 Hook，如 CartProvider 和 useCart。CartProvider 将 useReducer 的结果放入上下文，useCart 允许组件访问购物车状态。\n\n// CartContext.js\n\n```tsx\nimport React, { createContext, useReducer, useContext } from 'react';\n\nconst CartContext = createContext();\n\nfunction cartReducer(state, action) {\n  switch (action.type) {\n    case 'ADD_TO_CART':\n      return { items: [...state.items, action.payload] };\n    case 'REMOVE_FROM_CART':\n      return { items: state.items.filter(item => item.id !== action.payload) };\n    default:\n      return state;\n  }\n}\n\nfunction CartProvider({ children }) {\n  const [cart, dispatch] = useReducer(cartReducer, { items: [] });\n\n  return (\n    <CartContext.Provider value={{ cart, dispatch }}>\n      {children}\n    </CartContext.Provider>\n  );\n}\n\nfunction useCart() {\n  const context = useContext(CartContext);\n  if (context === undefined) {\n    throw new Error('useCart must be used within a CartProvider');\n  }\n  return context;\n}\n\nexport { CartProvider, useCart };\n```\n\n然后，可以在应用中的各个组件中使用 useCart Hook 来访问和修改购物车状态，而不需要将购物车状态一层层地传递。\n\n在 Product 组件中，通过使用 useCart Hook，它可以访问购物车上下文中的 dispatch 函数，以便将商品添加到购物车中。\n\n// Product.js\n\n```tsx\nimport React from 'react';\nimport { useCart } from './CartContext';\n\nfunction Product({ product }) {\n  const { dispatch } = useCart();\n\n  const addToCart = () => {\n    dispatch({ type: 'ADD_TO_CART', payload: product });\n  };\n\n  return (\n    <div>\n      <h2>{product.name}</h2>\n      <p>Price: {product.price}</p>\n      <button onClick={addToCart}>Add to Cart</button>\n    </div>\n  );\n}\n```\n\n在 Cart 组件中，同样使用 useCart Hook 来访问购物车状态和 dispatch 函数，以展示购物车内容并允许从购物车中移除商品。\n\n// Cart.js\n\n```tsx\nimport React from 'react';\nimport { useCart } from './CartContext';\n\nfunction Cart() {\n  const { cart, dispatch } = useCart();\n\n  const removeFromCart = (productId) => {\n    dispatch({ type: 'REMOVE_FROM_CART', payload: productId });\n  };\n\n  return (\n    <div>\n      <h2>Shopping Cart</h2>\n      <ul>\n        {cart.items.map((item) => (\n          <li key={item.id}>\n            {item.name} - ${item.price}\n            <button onClick={() => removeFromCart(item.id)}>Remove</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n### 5. useCallback: 用于优化性能，特别是在处理回调函数时，以避免不必要的重新渲染\n\n#### 5.1 基本语法\n\n```tsx\n const memoizedCallback = useCallback(callback, dependencies);\n// callback: 是一个函数，需要被缓存的函数。\n// dependencies: 回调函数所依赖的值数组,如果数组值发生变化,则生成新的函数\n```\n\n#### 5.2 使用方式\n\n假设你有一个父组件，它传递一个回调函数给子组件。如果不使用 useCallback，每次父组件重新渲染时，回调函数都会重新创建，导致子组件不必要地重新渲染。\n\n```tsx\nimport React, { useState } from 'react';\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <ChildComponent onClick={handleClick} />\n    </div>\n  );\n}\n\nfunction ChildComponent({ onClick }) {\n  return <button onClick={onClick}>Increment</button>;\n}\n```\n\nhandleClick 每次父组件重新渲染时都会重新创建，导致子组件重新渲染。为了避免这种情况，你可以使用 useCallback：\n\n```tsx\nimport React, { useState, useCallback } from 'react';\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() => {\n    setCount(count + 1);\n  }, [count]);\n\n  return (\n    <div>\n      <ChildComponent onClick={handleClick} />\n    </div>\n  );\n}\n\nfunction ChildComponent({ onClick }) {\n  return <button onClick={onClick}>Increment</button>;\n}\n```\n\n### 6. useRef: 获取对 DOM 元素的引用\n\n#### 6.1 基本语法\n\n```tsx\nconst myRef = useRef(initialValue);\n// initialValue 是可选的，它可以设置初始值。\n// 通常情况下，initialValue 在创建 Ref 时设置为 null。\n```\n\n#### 6.2 使用方式: 访问 DOM 元素\n\n```tsx\nimport React, { useRef, useEffect } from 'react';\n\nfunction MyComponent() {\n  const myInputRef = useRef(null);\n\n  useEffect(() => {\n    // 通过 myRef.current 访问该元素\n    myInputRef.current.focus();\n  }, []);\n\n  return <input ref={myInputRef} />;\n}\n```\n\n#### 6.3 存储可变数据: 使用 useRef 存储可变数据，不会引发组件的重新渲染\n\n```tsx\nimport React, { useRef } from 'react';\n\nfunction Timer() {\n  // count 是一个 useRef 对象，它在多次渲染之间保持不变，并用于计算计时器的值。\n  const count = useRef(0);\n\n  const startTimer = () => {\n    setInterval(() => {\n      count.current += 1;\n      console.log(`Timer count: ${count.current}`);\n    }, 1000);\n  };\n\n  return (\n    <div>\n      <button onClick={startTimer}>Start Timer</button>\n    </div>\n  );\n}\n```\n\n#### 6.4 访问子组件或函数组件的内部状态: 通过将 useRef 传递给子组件，你可以在父组件中访问子组件的状态或操作子组件的方法\n\n```tsx\nimport React, { useRef } from 'react';\n\nfunction ParentComponent() {\n  const childRef = useRef(null);\n\n  const handleChildClick = () => {\n    childRef.current.doSomething();\n  };\n\n  return (\n    <div>\n      <ChildComponent ref={childRef} />\n      <button onClick={handleChildClick}>Call Child's Method</button>\n    </div>\n  );\n}\n\nfunction ChildComponent() {\n  const doSomething = () => {\n    // 在子组件中执行某些操作\n  };\n\n  return <div>Child Component</div>;\n}\n```\n\n### 7 使用React Hooks需要遵循的规则\n\n#### 7.1 只在函数最外层调用Hooks,不要在循环、条件判断或者子函数中调用\n\n这是为了确保Hooks在每次渲染中都按照同样的顺序被调用,这样React才能正确地保存Hooks的状态\n\n错误示例:\n\n```tsx\n// 在条件判断中调用Hook:\nfunction Counter() {\n const [count, setCount] = useState(0);\n\n  if (count > 5) {\n    const [highCount, setHighCount] = useState(0); // 错误!在条件判断中调用\n  }\n\n  // ...\n}\n```\n\n#### 7.2仅在React函数组件或自定义Hooks中调用其他的Hooks\n\n不要在普通的JavaScript函数中调用\n\n### 8 自定义Hooks\n\n#### 8.1 创建自定义的 Hook，应该以 \"use\" 前缀命名\n\n// useTheme.js 自定义 Hook 处理主题切换逻辑\n\n```tsx\nimport { useState } from 'react';\n\nfunction useTheme() {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(theme === 'light' ? 'dark' : 'light');\n  };\n\n  return { theme, toggleTheme };\n}\n\nexport default useTheme;\n```\n\n#### 8.2 在组件中使用自定义 Hook\n\n// ThemeSwitcher.js\n\n```tsx\nimport React from 'react';\nimport useTheme from './useTheme';\n\nfunction ThemeSwitcher() {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    <div>\n      <p>Current Theme: {theme}</p>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n    </div>\n  );\n}\n\nexport default ThemeSwitcher;\n```\n\n#### 8.3 可以在多个组件中共享同一个自定义 Hook，从而避免重复编写相同的逻辑\n\n// AnotherComponent.js\n\n```tsx\nimport React from 'react';\nimport useTheme from './useTheme';\n\nfunction AnotherComponent() {\n  const { theme } = useTheme();\n\n  return <p>Theme in AnotherComponent: {theme}</p>;\n}\n```\n"},{"title":"stableDffision","tags":["game","stable dffision"],"categories":["game"],"author":"akko","excerpt":"\n- stable diffision\n- automatic 1111\n  - python\n  - git\n","link":"/posts/stableDffision/01.install","content":"\n- stable diffision\n- automatic 1111\n  - python\n  - git\n"},{"title":"unity","tags":["game","unity"],"categories":["game"],"author":"akko","excerpt":"","link":"/posts/unity/1.%E5%85%A5%E9%97%A8","content":""},{"title":"loadEnv","tags":["Vite源码分析"],"categories":["Vite"],"author":"akko","excerpt":"\n<!-- add some music -->\n<!-- playlist 歌单 -->\n<meting-js\n id=\"1357705810\"\n server=\"netease\"\n type=\"s","link":"/posts/vite/loadEnv","content":"\n<!-- add some music -->\n<!-- playlist 歌单 -->\n<meting-js\n id=\"1357705810\"\n server=\"netease\"\n type=\"song\"\n theme=\"#2980b9\">\n</meting-js>\n\n### env 的使用\n\n```ts\nimport { loadEnv } from 'vite'\n\nloadEnv('development', process.cwd())\n```\n\n检查 process.cwd()路径下.env.development.local、.env.development、.env.local、.env 这四个环境文件。\n输出 NODEENV 和 VITE开头的键值对。\nVITE_开头的键值对后面的不会覆盖前面的。\nNODE_ENV 的值后面的会覆盖前面的。\n\n## lookupFile源码\n\n```ts\n// ↓加载node的path模块\nvar path$1 = require('path')\nvar fs$2 = require('fs')\n\n// ↓传入的如果是一个包含'default'的key的对象，则输出对象的'default'的key对应的value。\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e['default'] : e\n}\n\n// ↓结合上面二者\nvar path__default = /*#__PURE__*/ _interopDefaultLegacy(path$1)\nvar fs__default = /*#__PURE__*/ _interopDefaultLegacy(fs$2)\n\n// ↓检查dir下是否有formats中的路径，返回有就返回路径或者文件\nfunction lookupFile(dir, formats, pathOnly = false) {\n  for (const format of formats) {\n    // ↓输出dir和formats连接后的路径\n    const fullPath = path__default.join(dir, format)\n    // ↓同步的检查该路径是否存在，并且该路径对应的是一个文件\n    if (fs__default.existsSync(fullPath) && fs__default.statSync(fullPath).isFile()) {\n      // ↓是否只要输出路径，否则输出文件\n      return pathOnly ? fullPath : fs__default.readFileSync(fullPath, 'utf-8')\n    }\n  }\n  // ↓上面的路径都不满足输出条件，那么再检查一遍检查传入的dir的目录名\n  const parentDir = path__default.dirname(dir)\n  if (parentDir !== dir) {\n    return lookupFile(parentDir, formats, pathOnly)\n  }\n}\n```\n\n## loadEnv 源码\n\n```ts\n// 从传参的root目录下获取\n// 按顺序 .env.${mode}.local、.env.${mode}、.env.local、.env这四个环境文件\n// 输出文件内配置的对象\nfunction loadEnv(mode, root, prefix = 'VITE_') {\n  if (mode === 'local') {\n    // ↓如果第一个参数传入'local'，就报错：\n    // ↓\"local \"不能用作模式名称，因为它与``.env文件的.local后缀冲突。\n    throw new Error(\n      `\"local\" cannot be used as a mode name because it conflicts with` +\n        `the .local postfix for .env files.`\n    )\n  }\n  // ↓待输出的环境变量对象\n  const env = {}\n  // ↓要读取的四个文件名称的字符串数组\n  const envFiles = [\n    /** mode local file */ `.env.${mode}.local`,\n    /** mode file */ `.env.${mode}`,\n    /** local file */ `.env.local`,\n    /** default file */ `.env`,\n  ]\n  // 检查是否有实际的以VITE_*开头的环境变量。\n\n  // 这些通常是Node内联提供的env对象，并应优先考虑。\n  for (const key in process.env) {\n    if (key.startsWith(prefix) && env[key] === undefined) {\n      env[key] = process.env[key]\n    }\n  }\n\n  for (const file of envFiles) {\n    // ↓检查根目录下是否有指定配置文件\n    const path = lookupFile(root, [file], true)\n    if (path) {\n      // ↓以换行为单位输出文件中KEY=VAL格式的到结果对象中\n      const parsed = main$2.parse(fs__default.readFileSync(path), {\n        debug: !!process.env.DEBUG || undefined,\n      })\n      // ↓让环境变量互相使用，这个方法我没仔细研究。不是很懂\n      main$1({\n        parsed,\n        // ↓防止process.env修改\n        ignoreProcessEnv: true,\n      })\n      // 只输出以prefix开头的key\n      for (const [key, value] of Object.entries(parsed)) {\n        // ↓只有这个key在前面没有加载过才赋值\n        if (key.startsWith(prefix) && env[key] === undefined) {\n          env[key] = value\n        } else if (key === 'NODE_ENV') {\n          // 在.env文件中覆盖NODE_ENV。\n          process.env.VITE_USER_NODE_ENV = value\n        }\n      }\n    }\n  }\n  return env\n}\n```\n"},{"title":"cocos2/3d入门","tags":["game","cocos"],"categories":["cocos"],"author":"akko","excerpt":"\n## cocos3x入门教程\n\n<https://forum.cocos.org/t/topic/122399>\n\n## 创建部分略过\n\n### 创建场景\n\n![Alt text](./img/im","link":"/posts/cocos/01.%E5%85%A5%E9%97%A8/1.%E5%85%A5%E9%97%A8","content":"\n## cocos3x入门教程\n\n<https://forum.cocos.org/t/topic/122399>\n\n## 创建部分略过\n\n### 创建场景\n\n![Alt text](./img/image.png)\n\n### 创建物体\n\n![Alt text](./img/image-1.png)\n\n### 新建脚本\n\n![Alt text](./img/image-2.png)\n\n- 激活脚本\n 在脚本中添加 start() 函数，start() 函数会在组件第一次激活时调用\n 双击即可打开脚本在你喜欢的编辑器，当然前提你得设置，或者你只有一个编辑器，就像我一样\n\n### 绑定脚本\n\n在 层级管理器 中选中创建的 Cube 节点，然后在 属性检查器 面板最下方点击 添加组件 -> 自定义脚本 ->\n![Alt text](./image.png)\n\n### 预览场景\n\n选中对应的场景点启动\n![Alt text](./image-1.png)\n\n- 最终会在控制台输入激活后的副作用\n![Alt text](./image-2.png)\n\n## 修改场景中的 Camera\n\n在预览中我们可以看到立方体似乎有点太小了，通过调整场景中的 Camera 来调整场景运行时显示的区域，\n\n- Camera 代表的是游戏中的玩家视角。\n\n选中一个camera,这里选中main\n\n![Alt text](./image-3.png)\n\n### 拖动相机\n\n拖动相机呢，相当于我们玩家玩游戏时候的转动的第一视角，就像这样\n\n![Alt text](./image-4.png)\n\n### 放大物体\n\n此处需要你稍微具有点初中物理的知识，\n\n- 远小近大\n\n![Alt text](./image-5.png)\n所以 我们想要把物体放大一点，就需要让这个cube更靠近这个视角的顶点\n\n![Alt text](./image-6.png)\n记住和右上角的相同颜色的轴，单击选中同颜色的轴就可以改变当前轴的深度了\n比如把蓝色往上 就相当于 z轴更高，这样视角就离物体比较远了\n\n`点选对应颜色的轴，拖动即可快速调整视角的位置`\n\n![Alt text](./image-7.png)\n现在就变得很大了，记得ctrl+s保存哦,会自动更新的，就像hmr一样\n"},{"title":"cocos3d项目结构","tags":["game","cocos"],"categories":["cocos"],"author":"akko","excerpt":"\n![Alt text](./image-1.png)\n在资源管理器中显示\n\n## 目录结构\n\n![Alt text](./image.png)\n\n### .creator\n\n  是一些模板，后面再说","link":"/posts/cocos/02.%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84","content":"\n![Alt text](./image-1.png)\n在资源管理器中显示\n\n## 目录结构\n\n![Alt text](./image.png)\n\n### .creator\n\n  是一些模板，后面再说\n\n### .git\n\n  这个不知道的话，建议百度 【做程序的应该没有不知道的】\n\n### .vscode 主要是一些vsc的配置文件\n\n### assets：资源目录\n\n    本地资源、脚本和第三方库文件\n    只有在 assets 目录下的内容才能显示在 资源管理器 中。\n    .meta 可以理解为sourcemap的作用，用来存储资源配置对应的索引\n    .meta 文件需要一并提交到版本控制系统\n    .psd文件可以放在assets外部\n\n### build：构建目录（在构建某平台后会生成该目录）\n\n    项目 -> 构建发布\n    之后会创建一个build目录用来存放构建的工程\n    类似于dist\n\n![Alt text](./image-2.png)\n点击构建后，可选发布平台\n\n构建后的web产物\n![Alt text](./image-3.png)\n\n### library：导入的资源目录\n\n    是assets导入后生成的，在这里文件的结构会处理成游戏最终发布的格式\n    丢失或损坏时，删除library，然后再重新打开即可\n\n### local：日志文件目录\n\n### profiles：编辑器配置\n\n### temp：临时文件目录\n\n### package.json：项目配置\n"},{"title":"01.express向前提供http服务","tags":["game","cocos"],"categories":["cocos"],"author":"akko","excerpt":"\nexpress呢是一个npm包啦，要使用它也很简单只需要一行shell\n\n```bash\npnpm i express\n```\n然后打开浏览器 搜索 express npm\n![alt text](","link":"/posts/cocos/03.http%E6%9C%8D%E5%8A%A1","content":"\nexpress呢是一个npm包啦，要使用它也很简单只需要一行shell\n\n```bash\npnpm i express\n```\n然后打开浏览器 搜索 express npm\n![alt text](./image.png)\n\n```bash\nconst express = require('express')\nconst app = express()\n\napp.get('/', function (req, res) {\n  res.send('Hello World')\n})\n\napp.listen(3000)\n```\n使用起来也很简单，它是cjs的模块哈，引入这个包 然后调用了express的函数 然后有暴露get、post之类的方法，第一个入参一个路由，第二个入参接受一个callback function，然后调用了send方法，实际上和koa2一样 应该都是调用的http.createServer()这个方法，node下面的模块\n\n不过更推荐安装\n```bash\nnpm install -g express-generator@4\n```\n懒得写了直接看图吧\n![alt text](./image-1.png)\n\n然后访问https://localhost:3000 看到字符串就成功了\n"},{"title":"02.cors解决跨域请求","tags":["game","cocos"],"categories":["cocos"],"author":"akko","excerpt":"\n## 登录\n\n在前端有个这样的login组件，后续解释代码\n\n```ts\nimport { _decorator, Component, EditBox, Node } from 'cc';\ncon","link":"/posts/cocos/04.cors","content":"\n## 登录\n\n在前端有个这样的login组件，后续解释代码\n\n```ts\nimport { _decorator, Component, EditBox, Node } from 'cc';\nconst { ccclass, property } = _decorator;\nimport Crypt from 'jsencrypt'\nimport { PublicKey } from '../common';\n\nconst crypt = new Crypt()\ncrypt.setKey(PublicKey)\n\n@ccclass('LoginManger')\nexport class LoginManger extends Component {\n    account: EditBox\n    password: EditBox\n\n    /**\n     * Method called when the component is loaded.\n     */\n    onLoad() {\n        this.account = this.node.getChildByName('Account').getComponent(EditBox);\n        this.password = this.node.getChildByName('Password').getComponent(EditBox);\n    }\n\n    /**\n     * A description of the entire function.\n     *\n     * @param {type} paramName - description of parameter\n     * @return {type} description of return value\n     */\n    async register() {\n        const account = crypt.encrypt(this.account.string);\n        const password = crypt.encrypt(this.password.string);\n\n        console.log('account :>> ', account);\n        console.log('password :>> ', password);\n\n        const res = await fetch(\"http://localhost:3000/register\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({ account, password }),\n        })\n            .then((response) => response.json())\n        console.log('res :>> ', res);\n    }\n}\n```\n使用fetch发送请求\n\n后端代码改成\n由于express没有对body做处理，所以还需要这个包`body-parser`\n相当于中间件直接use就行了\n\n```ts\nimport express from 'express'\nimport cors from 'cors'\nimport bodyParser from 'body-parser'\n\nconst app = express()\nconst port = 3000\n\napp.use(cors())\napp.use(bodyParser.json())\n\n\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\napp.post('/register', (req, res) => {\n  console.log('req :>> ', req.body);\n  let { account, password } = req.body\n\n  res.json({\n    code: 200,\n    account,\n    password,\n  })\n  console.log('account :>> ', account); ``\n  console.log('password :>> ', password);\n})\n\napp.listen(port, () => console.log(`Example app listening on port https://localhost:${port}`))\n\nconsole.log(\"auth 服务\");\n```\n## 问题\n用cocos打开之后也简单\n但是输入密码发送请求的时候发现是明文发送 这个其实不太好，下一篇文章解决\n"},{"title":"03.非对称加密","tags":["game","cocos"],"categories":["cocos"],"author":"akko","excerpt":"![alt text](./image.png)\n\n关于加密的相关此处不展开，可以通过中间人，sql注入这些攻击，但是我们只需要发送到server是加密的就行 所以 需要用到2个npm库\n\n前端\n``","link":"/posts/cocos/05.%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86","content":"![alt text](./image.png)\n\n关于加密的相关此处不展开，可以通过中间人，sql注入这些攻击，但是我们只需要发送到server是加密的就行 所以 需要用到2个npm库\n\n前端\n```bash\npnpm i  jsencrypt\n```\n\n后端\n\n```bash\npnpm i node-jsencrypt\n```\n\n### 前端公钥加密，用常用的rsa加密算法，rsa网上一堆生成网站\n\n```ts\nimport Crypt from 'jsencrypt'\nimport { PublicKey } from '../common';\n\nconst crypt = new Crypt()\ncrypt.setKey(PublicKey)\n\n  const account = crypt.encrypt(this.account.string);\n  const password = crypt.encrypt(this.password.string);\n```\n整体代码如下\n```ts\nimport { _decorator, Component, EditBox, Node } from 'cc';\nconst { ccclass, property } = _decorator;\nimport Crypt from 'jsencrypt'\nimport { PublicKey } from '../common';\n\nconst crypt = new Crypt()\ncrypt.setKey(PublicKey)\n\n@ccclass('LoginManger')\nexport class LoginManger extends Component {\n    account: EditBox\n    password: EditBox\n\n    /**\n     * Method called when the component is loaded.\n     */\n    onLoad() {\n        this.account = this.node.getChildByName('Account').getComponent(EditBox);\n        this.password = this.node.getChildByName('Password').getComponent(EditBox);\n    }\n\n    /**\n     * A description of the entire function.\n     *\n     * @param {type} paramName - description of parameter\n     * @return {type} description of return value\n     */\n    async register() {\n        const account = crypt.encrypt(this.account.string);\n        const password = crypt.encrypt(this.password.string);\n\n        console.log('account :>> ', account);\n        console.log('password :>> ', password);\n\n        const res = await fetch(\"http://localhost:3000/register\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({ account, password }),\n        })\n            .then((response) => response.json())\n        console.log('res :>> ', res);\n    }\n}\n\n```\n\n### 后端 同样引入解密的包，然后用私钥去解密码\n\n```ts\n// @ts-ignore\nimport Crypt from 'node-jsencrypt'\n\nimport { PrivateKey } from '../common'\n\nconst crypt = new Crypt()\ncrypt.setKey(PrivateKey)\n\nlet { account, password } = req.body\n  account = crypt.decrypt(account)\n  password = crypt.decrypt(password)\n```\n\n整体代码如下\n```ts\nimport express from 'express'\nimport cors from 'cors'\nimport bodyParser from 'body-parser'\n// @ts-ignore\nimport Crypt from 'node-jsencrypt'\n\nimport { PrivateKey } from '../common'\n\nconst crypt = new Crypt()\ncrypt.setKey(PrivateKey)\n\nconst app = express()\nconst port = 3000\n\napp.use(cors())\napp.use(bodyParser.json())\n\n\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\napp.post('/register', (req, res) => {\n  console.log('req :>> ', req.body);\n  let { account, password } = req.body\n  account = crypt.decrypt(account)\n  password = crypt.decrypt(password)\n\n  res.json({\n    code: 200,\n    account,\n    password,\n  })\n  console.log('account :>> ', account); ``\n  console.log('password :>> ', password);\n})\n\napp.listen(port, () => console.log(`Example app listening on port https://localhost:${port}`))\n\nconsole.log(\"auth 服务\");\n```\n\n### 问题\n\n加密完成后，输入密码可以在控制台看到 已经是看不到明文的密码了，但是数据肯定是要把玩家信息保存起来 才能登录另一个玩家，毕竟是mmoact，可以用mysql，下一篇文章学习下\n"},{"title":"04.Docker启动mysql","tags":["mysql","game"],"categories":["mysql"],"author":"akko","excerpt":"\nmysql呢，安装起来麻烦，所以就需要docker，我推荐docker desktop，安装省略\n\n### 1. 在docker仓库中搜索mysql的镜像：\n```bash\n docker sear","link":"/posts/cocos/06.mysql","content":"\nmysql呢，安装起来麻烦，所以就需要docker，我推荐docker desktop，安装省略\n\n### 1. 在docker仓库中搜索mysql的镜像：\n```bash\n docker search mysql\n```\n下载镜像：\n```bash\ndocker pull mysql\n```\n\n### 2. 查看本地镜像：\n```bash\n docker images -a\n```\n     a.  参数-a 表示所有\n\n     b. 启动 mysql 容器，并进入 shell 命令交互界面： docker run -it mysql /bin/bash\n\n  (  参数 -i -t 等价于 -it  表示insert , 进入 ;  /bin/bash 表示 shell 脚本交互界面 )\n\n     c. 可用 mysql --help | grep Distrib 查看 mysql 版本信息\n\n （ mysql --help 查看帮助信息，并在结果集中 查找 Distrib ， “|”单竖线表示命令的连续执行，同时以前一个命令值域作为后一个命令的定义域 ）\n\n### 3. 退出 当前交互窗口：exit 。此操作会关闭 mysql 服务 。\n\n（对于创建的bush 容器，exit 退出后，容器也会退出。\n\n   这是因为对Docker 来说，容器中的应用退出了，容器也就没有必要继续运行了。）\n\n—— 想要服务一直运行可以：\n\n```bash\n docker run -p 3306:3306 --name JY_mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n```\n（参数 -p 设置端口，--name 取名 ，-e MYSQL_ROOT_PASSWORD=123456 设置 账号为 root ，密码为 123456 ，-d 表示作为一个守护进程在后台运行 ）\n\n### 4. 查看运行中的容器：\n```bash\ndocker ps\n```\n（可加参数 -a 表示所有，如果不加这个参数只会展示运行状态的容器，\n\n  按容器即服务的思想，某种程度上可以把容器也当作服务，）\n\n\n这样 mysql 就已安装并成功启动，处于运行状态了。\n\n可以通过 docker port 容器name 查看对应端口：\n\n### 5. 至于相关文件地址配置 ，可以在运行容器时设置 ：\n\n```bash\ndocker run -p 3306:3306 --name mysql -v $PWD/conf/my.cnf:/etc/mysql/my.cnf -v $PWD/logs:/logs -v $PWD/data:/mysql_data -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n```\n但要求对应路径对应文件已存在，才能成功挂载相内容到对应位置。\n\n命令说明：\n -p 3306:3306：将容器的3306端口映射到主机的3306端口\n -v $PWD/conf/my.cnf:/etc/mysql/my.cnf：将主机当前目录下的conf/my.cnf挂载到容器的/etc/mysql/my.cnf\n -v $PWD/logs:/logs：将主机当前目录下的logs目录挂载到容器的/logs\n -v $PWD/data:/mysql_data：将主机当前目录下的data目录挂载到容器的/mysql_data\n -e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码\n\ndocker启动好这样就是启动了\n![alt text](./image-1.png)\n\n## 连接\n![alt text](./image.png)\n安装这个插件\n\n然后点左侧的倒数第二个图标，创建一个链接\n![alt text](./image-2.png)\n\n3306新建一个数据库\n![alt text](./image-3.png)\n\n### 表\n存储密码和账号，需要一个user表\n![alt text](./image-4.png)\n\n### accout和password字段\n新建2个字段 varchar就行 然后20个字符长度\n![alt text](./image-5.png)\n\n### 连接数据库\n\n```bash\npnpm install mysql\n```\n安装之后它的npm主页也有使用方法\n![alt text](./image-7.png)\n直接复制这里面的代码，把表名字和密码账号改一下就行\n\n### 执行sql语句\n直接写sql语句会有sql注入风险，通常都是通过？？？占位符处理\n\n![alt text](./image-6.png)\n\n## mysql2\n之前那个包会报错一个\nClient does not support authentication protocol requested by server; consider upgrading MySQL client\n所以使用新包试试\nhttps://sidorares.github.io/node-mysql2/docs#first-query\n\n```ts\nimport mysql from 'mysql2';\n\n  const connection = mysql.createConnection({\n    host: 'localhost',\n    user: 'root',\n    password: '123456',\n    database: 'mmoactdb',\n  });\n\n  // 注册中\n  connection.execute(\n    'INSERT INTO user (account, password, create_time) VALUES (?, ?, ?)',\n    [account, password, dayjs().format('YYYY-MM-DD HH:mm:ss')],\n    function (err, results, fields) {\n      if (err) {\n        console.log('err :>> ', err)\n        return\n      }\n      console.log(results)\n      console.log(fields)\n    }\n  );\n```\n\nts-node不知道为什么在esm下面会报错 所以不得不使用cjs的格式\n\n### 启动游戏\n注册账号\n![alt text](./image-9.png)\n表里面已经有数据了\n![alt text](./image-8.png)\n但是明文存储账号密码在数据库里面不太好，所以还需要把密码账号用哈希散列算法混淆一下，这样即使用户数据被盗 还是有一层保障\n"},{"title":"05.crypto哈希散列MD5混淆","tags":["mysql","game"],"categories":["mysql"],"author":"akko","excerpt":"\n## crypto\n![alt text](./image.png)\n\n## createHash\n![alt text](./image-1.png)\ncreateHash方法调用的时候使用md5","link":"/posts/cocos/07.%E5%93%88%E5%B8%8C%E6%95%A3%E5%88%97%E6%B7%B7%E6%B7%86","content":"\n## crypto\n![alt text](./image.png)\n\n## createHash\n![alt text](./image-1.png)\ncreateHash方法调用的时候使用md5，然后update和digest\n\n```ts\nimport express from 'express'\nimport { createHash } from 'crypto';\nimport cors from 'cors'\nimport mysql from 'mysql2';\nimport dayjs from 'dayjs';\nimport bodyParser from 'body-parser'\n// @ts-ignore\nimport Crypt from 'node-jsencrypt'\n\nimport { PrivateKey } from '../common'\n\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '123456',\n  database: 'mmoactdb',\n});\n\nconst crypt = new Crypt()\ncrypt.setKey(PrivateKey)\n\nconst app = express()\nconst port = 3000\n\napp.use(cors())\napp.use(bodyParser.json())\n\n\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\napp.post('/register', (req, res) => {\n  console.log('req :>> ', req.body)\n  let { account, password } = req.body\n  account = crypt.decrypt(account)\n  password = crypt.decrypt(password)\n\n  const hash = createHash('md5');\n  const passwordHash = hash.update(password).digest('hex');\n\n  connection.execute(\n    'INSERT INTO user (account, password, create_time) VALUES (?, ?, ?)',\n    [account, passwordHash, dayjs().format('YYYY-MM-DD HH:mm:ss')],\n    function (err, results, fields) {\n      if (err) {\n        console.log('err :>> ', err)\n        return\n      }\n      console.log(results)\n      console.log(fields)\n    }\n  );\n\n  res.json({\n    code: 200,\n    account,\n    password,\n  })\n  console.log('account :>> ', account)\n  console.log('password :>> ', password)\n})\n\napp.listen(port, () => console.log(`Example app listening on port https://localhost:${port}`))\n\nconsole.log(\"auth 服务\")\n```\n![alt text](./image-2.png)\n## 密码需要更新成32位的\n![alt text](./image-3.png)\n"},{"title":"06.uuid生成token","tags":["game","游戏登录","cocos"],"categories":["uuid"],"author":"akko","excerpt":"\n### uuid\n\n```bash\npnpm install uuid\n```\n\n### token\n![alt text](./image.png)\n\n### login\n登录和注册一样，从表里面","link":"/posts/cocos/08.uuid%E7%94%9F%E6%88%90token","content":"\n### uuid\n\n```bash\npnpm install uuid\n```\n\n### token\n![alt text](./image.png)\n\n### login\n登录和注册一样，从表里面查对应account和password就行了\n\n```ts\nconst cache = new Map()\n\napp.post('/login', (req, res) => {\n  console.log('req :>> ', req.body)\n  let { account, password } = req.body\n  account = crypt.decrypt(account)\n  password = crypt.decrypt(password)\n\n  const hash = createHash('md5');\n  const passwordHash = hash.update(password).digest('hex');\n\n  connection.execute(\n    'SELECT * FROM user WHERE account = ? AND password = ?',\n    [account, passwordHash],\n    (err, results: any[], fields): void => {\n      if (err) {\n        console.log('err :>> ', err);\n        return;\n      }\n      if (results.length > 0) {\n        const token = uuidv4()\n        cache.set(token, account),\n          res.json({\n            code: 200,\n            message: '登录成功',\n            token\n          })\n        console.log('cache :>> ', cache);\n      } else {\n        res.json({\n          code: 400,\n          message: '登录失败,账号不存在或密码错误'\n        })\n      }\n    }\n  );\n})\n```\n\n### client\n\nclient里面也需要改造一下\n```ts\nasync login() {\n        const account = crypt.encrypt(this.account.string);\n        const password = crypt.encrypt(this.password.string);\n\n        console.log('account :>> ', account);\n        console.log('password :>> ', password);\n\n        const res = await fetch(\"http://localhost:3000/login\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({ account, password }),\n        })\n            .then((response) => response.json())\n        console.log('res :>> ', res);\n    }\n```\n\nlogin方法和注册是一样的，fetch不同的路由即可\n"},{"title":"07.gateway","tags":["game","游戏登录","cocos","gateway"],"categories":["gateway"],"author":"akko","excerpt":"\n### gateway\n\ngateway 网关服务，为什么需要做呢？\n\n- 首先，游戏登录界面可能需要多个和游戏服务器通信，而这些服务肯呢个位于不同的地理位置，网关服务可以将所有游戏服务器通信路由到","link":"/posts/cocos/09.gateway","content":"\n### gateway\n\ngateway 网关服务，为什么需要做呢？\n\n- 首先，游戏登录界面可能需要多个和游戏服务器通信，而这些服务肯呢个位于不同的地理位置，网关服务可以将所有游戏服务器通信路由到同一个地址\n- 游戏服务器可能需要跨区域的通信\n  - 因为默认游戏上线后是全国玩家都可以玩\n- 另外mmoact游戏服务需要处理大量玩家的链接来保持请求可以  分流和负载均衡\n\n### login\n在登录后呢，我们需要鉴权以及一系列操作，并且一直保持登录状态，然后我们要登录另一个玩家，所以需要长链接。\n- http 无状态\n- webscoket\n\n了解到websocket可以做到长链接，这和我们的需要一拍即合，在npm找一下\n![alt text](./image.png)\n\n## (元神)，startup\n![alt text](./image-1.png)\n\n## server\n新建一个gatewayManger主要用来做网关服务, 引入基础类和websocket的服务\n\n```ts\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { RpcFunc } from '../common';\nimport { Singleton } from '../common/common/base';\n\nconst wss = new WebSocketServer({ port: 4000 });\n\nexport class GatewayManger extends Singleton {\n  static get Instance() {\n    return super.GetInstance<GatewayManger>();\n  }\n\n  init() {\n    console.log('GatewayManger init');\n    wss.on('connection', (ws) => {\n      ws.on('error', console.error);\n\n      ws.on('message', (buffer: Buffer) => {\n        this.handleMessage(ws, buffer);\n      });\n    });\n  }\n\n  // 处理接受到的消息\n  handleMessage(ws: WebSocket, buffer: Buffer): void {\n    console.log(buffer.toString());\n    const { name, data } = JSON.parse(buffer.toString());\n\n    if (name === RpcFunc.enterGame) {\n      // TODO 进入游戏场景 做鉴权\n    } else {\n      // TODO 跟Game服务通信\n    }\n    ws.send(buffer.toString());\n  }\n}\n```\n\n并在入口文件init一下\n\n```ts\nimport { GatewayManger } from './GatewayManger';\n\nGatewayManger.Instance.init()\n```\n\n至此后端的长连接就搞定了，然后新开一个bash, yarn gateway启动一下gateway服务\n\n## client\n\n前端呢需要首先在登录之后做调用长链接\n\n```ts\n  async login() {\n    const account = crypt.encrypt(this.account.string);\n    const password = crypt.encrypt(this.password.string);\n\n    console.log('account :>> ', account);\n    console.log('password :>> ', password);\n\n    const res = await fetch(\"http://localhost:3000/login\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ account, password }),\n    })\n        .then((response) => response.json())\n    console.log('res :>> ', res);\n\n    this.connect(res.token);\n  }\n\n  // ws的长连接\n  async connect() {\n    await NetworkManager.Instance.connect()\n    const res = await NetworkManager.Instance.call(RpcFunc.enterGame, { token });\n    console.log('connect :>> ', res);\n  }\n\n  // NetworkManager.ts\n  import { Singleton } from \"../common/base\";\n  import { getProtoPathByRpcFunc, RpcFunc, ProtoPathEnum, ServerPort } from \"../common\";\n  // @ts-ignore\n  import protoRoot from \"../proto/index.js\";\n\n  const TIMEOUT = 5000;\n\n  interface IItem {\n    cb: Function;\n    ctx: unknown;\n  }\n\n  export type IData = Record<string, any>;\n\n  export default class NetworkManager extends Singleton {\n    static get Instance() {\n      return super.GetInstance<NetworkManager>();\n    }\n\n    ws: WebSocket;\n    port = ServerPort.Gateway;\n    maps: Map<RpcFunc, Array<IItem>> = new Map();\n    isConnected = false;\n\n    connect() {\n      return new Promise((resolve, reject) => {\n        if (this.isConnected) {\n          resolve(true);\n          return;\n        }\n        this.ws = new WebSocket(`ws://localhost:${this.port}`);\n        //onmessage接受的数据类型，只有在后端返回字节数组的时候才有效果\n        this.ws.binaryType = \"arraybuffer\";\n\n        this.ws.onopen = () => {\n          this.isConnected = true;\n          resolve(true);\n        };\n\n        this.ws.onerror = (e) => {\n          this.isConnected = false;\n          console.log(e);\n          reject(\"ws error\");\n        };\n\n        this.ws.onclose = () => {\n          this.isConnected = false;\n          console.log(\"ws onclose\");\n          reject(\"ws close\");\n        };\n\n        this.ws.onmessage = (e) => {\n          try {\n            const { data, name } = JSON.parse(e.data);\n            try {\n              if (this.maps.has(name) && this.maps.get(name).length) {\n                this.maps.get(name).forEach(({ cb, ctx }) => cb.call(ctx, data));\n              } else {\n                console.log(`no ${name} message or callback, maybe timeout`);\n              }\n            } catch (error) {\n              console.log(\"call error:\", error);\n            }\n          } catch (error) {\n            console.log(\"onmessage parse error:\", error);\n          }\n        };\n      });\n    }\n\n    call(name: RpcFunc, data: IData) {\n      return new Promise<{ data?: any; error?: string }>((resolve) => {\n        try {\n          // 超时处理\n          const timer = setTimeout(() => {\n            resolve({ error: \"Time Out!\" });\n            this.unListen(name, cb, null);\n          }, TIMEOUT);\n\n          // 回调处理\n          const cb = (res) => {\n            resolve(res);\n            clearTimeout(timer);\n            this.unListen(name, cb, null);\n          };\n\n          // 监听响应事件触发回调\n          this.listen(name, cb, null);\n\n          // 发送消息\n          this.send(name, data);\n        } catch (error) {\n          resolve({ error });\n        }\n      });\n    }\n\n    async send(name: RpcFunc, data: IData) {\n      const obj = {\n        name,\n        data\n      }\n      this.ws.send(JSON.stringify(obj)); // 需要发送一个字符串\n    }\n\n    listen(name: RpcFunc, cb: (args: any) => void, ctx: unknown) {\n      if (this.maps.has(name)) {\n        this.maps.get(name).push({ ctx, cb });\n      } else {\n        this.maps.set(name, [{ ctx, cb }]);\n      }\n    }\n\n    unListen(name: RpcFunc, cb: (args: any) => void, ctx: unknown) {\n      if (this.maps.has(name)) {\n        const items = this.maps.get(name);\n        const index = items.findIndex((i) => cb === i.cb && i.ctx === ctx);\n        index > -1 && items.splice(index, 1);\n      }\n    }\n  }\n\n```\n\n## login\n\n![alt text](./image-2.png)\n\n这样到底为止，gateway服务的长连接就建立好了，接下来还要实现服务之间的调用，之后学习一下\n"},{"title":"08.grpc","tags":["game","游戏登录","cocos","grpc"],"categories":["grpc"],"author":"akko","excerpt":"\n\n## 为什么需要rpc以及rpc是什么？\n我就不班门弄斧了，直接看大佬的文章吧\n[怎么理解rpc，既然有http请求了为啥还要用rpc？](https://www.zhihu.com/questi","link":"/posts/cocos/10.grpc","content":"\n\n## 为什么需要rpc以及rpc是什么？\n我就不班门弄斧了，直接看大佬的文章吧\n[怎么理解rpc，既然有http请求了为啥还要用rpc？](https://www.zhihu.com/question/524580708/answer/2584782720)\n\n## grpc\n谷歌的高性能基于http2的rpc框架，使用它\n[grpc](https://grpc.io/docs/languages/node/quickstart/)\n\n简单来说 按照我的理解现在都是微服务架构和部署，这样服务之间的通信用rpc能做的事情就比较方便一点。\n\n### @grpc/grpc-js\n和往常一样，直接去npm找google的官网\n![alt text](./image.png)\n另外不会默认处理proto文件\n![alt text](./image-1.png)\n### @grpc/proto-loader\n![alt text](./image-2.png)\n\n\n## .proto\n\n```proto\nsyntax = \"proto3\";\n\npackage auth;\n\nservice Auth {\n  rpc checkToken(CheckTokenReq) returns (CheckTokenRes) {}\n}\n\nmessage CheckTokenReq {\n  string token = 1;\n}\n\nmessage CheckTokenRes {\n  CheckTokenResData data = 1;\n  optional string error = 2;\n}\n\nmessage CheckTokenResData {\n  string account = 2;\n}\n\n```\n## 开拔\n\nauth里面需要加一个authService\n\n```ts\nimport * as grpc from '@grpc/grpc-js';\n\nconst cache = new Map()\nconst server = new grpc.Server()\n\n// Server.addService(service: grpc.ServiceDefinition<grpc.UntypedServiceImplementation>, implementation: grpc.UntypedServiceImplementation): void\nserver.addService(AuthService, {\n  checkToken(call, callback) {\n    const token = call.request.getToken()\n    const data = new CheckTokenRes()\n\n    if (cache.has(token)) {\n      const data = new CheckTokenResData()\n      data.setAccount(cache.get(token))\n      res.setData(data)\n    } else {\n      res.setError('token is not exist')\n    }\n    callback(null, res)\n  }\n})\n\nserver.bindAsync('localhost:3333', grpc.ServerCredentials.createInsecure(), () => {\n  server.start()\n  console.log('authのrpc 服务启动成功')\n})\n```\n\n同时gateway里面也需要改造\n\n```ts\n  handleMessage(ws: WebSocket, buffer: Buffer): void {\n    console.log(buffer.toString());\n    const { name, data } = JSON.parse(buffer.toString());\n\n    if (name === RpcFunc.enterGame) {\n      // 进入游戏场景 做鉴权\n      this.checkTocken(data)\n    } else {\n      // 跟Game服务通信\n    }\n\n    ws.send(buffer.toString());\n  }\n\n  checkTocken({ token }: { token: string }) {\n    const client = new AuthClient('localhost:3333', grpc.credentials.createInsecure());\n\n    const req = new CheckTokenReq()\n    req.setToken(token);\n\n    client.checkToken(req, (err, message) => {\n      console.log(message.toObject())\n    })\n  }\n```\n![alt text](./image-3.png)\n\n## 问题\n![alt text](./image-4.png)\n现在登陆后发现都是用json传输数据的，需要压缩一下，下一篇文章学习下\n"},{"title":"09.protobuf","tags":["game","游戏登录","cocos","protobuf"],"categories":["protobuf"],"author":"akko","excerpt":"\nprotobuf是谷歌开源的二进制字节传输，由于手游要适配用户的不同手机，减少网络请求包能减小用户的手机发热耗电等问题，所以webscoket中压缩用户传输的数据就显得很重要\n\n### protob","link":"/posts/cocos/11.protobuf","content":"\nprotobuf是谷歌开源的二进制字节传输，由于手游要适配用户的不同手机，减少网络请求包能减小用户的手机发热耗电等问题，所以webscoket中压缩用户传输的数据就显得很重要\n\n### protobuf\n先跟着官网启动一个`grpc`服务\n[grpc](https://grpc.io/docs/languages/node/quickstart/)\n\ngRPC 是一个高性能的远程过程调用框架，使用 protobuf 定义二进制的数据结构。相比之下 RESTful API 是基于 http 超文本协议，性能可想而知 gRPC 是高不少的。gRPC 支持node.js，适用微服务、client-server 等场景\n\n### proto\nproto文件是谷歌约定的语法，类似于.d.ts对于接口或者类的方法约束\n```proto\nsyntax = \"proto3\";\n\noption java_multiple_files = true;\noption java_package = \"io.grpc.examples.helloworld\";\noption java_outer_classname = \"HelloWorldProto\";\noption objc_class_prefix = \"HLW\";\n\npackage helloworld;\n\n// The greeting service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n\n  rpc SayHelloStreamReply (HelloRequest) returns (stream HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n## protobuf的应用\n\n### client\n```ts\nvar PROTO_PATH = __dirname + '/../../protos/helloworld.proto';\n\nvar parseArgs = require('minimist');\nvar grpc = require('@grpc/grpc-js');\nvar protoLoader = require('@grpc/proto-loader');\nvar packageDefinition = protoLoader.loadSync(\n  PROTO_PATH,\n  {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true\n  });\nvar hello_proto = grpc.loadPackageDefinition(packageDefinition).helloworld;\n\nfunction main() {\n  var argv = parseArgs(process.argv.slice(2), {\n    string: 'target'\n  });\n  var target;\n  if (argv.target) {\n    target = argv.target;\n  } else {\n    target = 'localhost:50051';\n  }\n  var client = new hello_proto.Greeter(target,\n    grpc.credentials.createInsecure());\n  var user;\n  if (argv._.length > 0) {\n    user = argv._[0];\n  } else {\n    user = 'world111';\n  }\n  client.sayHello({ name: user }, function (err, response) {\n    console.log('Greeting:', response.message);\n  });\n}\n\nmain();\n```\n\n### server\n```ts\nvar PROTO_PATH = __dirname + '/../../protos/helloworld.proto';\n\nvar grpc = require('@grpc/grpc-js');\nvar protoLoader = require('@grpc/proto-loader');\nvar packageDefinition = protoLoader.loadSync(\n    PROTO_PATH,\n    {keepCase: true,\n     longs: String,\n     enums: String,\n     defaults: true,\n     oneofs: true\n    });\nvar hello_proto = grpc.loadPackageDefinition(packageDefinition).helloworld;\n\n/**\n * Implements the SayHello RPC method.\n */\nfunction sayHello(call, callback) {\n  callback(null, {message: 'Hello ' + call.request.name});\n}\n\n/**\n * Starts an RPC server that receives requests for the Greeter service at the\n * sample server port\n */\nfunction main() {\n  var server = new grpc.Server();\n  server.addService(hello_proto.Greeter.service, {sayHello: sayHello});\n  server.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => {\n    server.start();\n  });\n}\n\nmain();\n```\n\n## 开拔\n上面呢是个demo，简单的protobuf使用，很简单我就不详细介绍了\n接下来引入protobuf包的js cli和生成js文件的包，自动生成的js\n\n```bash\nimport protoRoot from \"../common/idl/auto-gen-ws\";\n```\n如果没有的话cd到root然后yarn common\n\n### server to client\n这个方法在之前是ws通信的时候校验了token的，然后需要调用发送信息实现一个sendMessgae方法\n\n```ts\n  import { AuthClient, CheckTokenReq, RpcFunc, getProtoPathByRpcFunc } from '../common';\n\n   async handleMessage(ws: WebSocket, buffer: Buffer): Promise<void> {\n    const name = buffer.readUint8(0);\n    const path = getProtoPathByRpcFunc(name, 'req')\n    const coder = protoRoot.lookup(path)\n    const data = coder.decode(buffer.slice(1))\n\n    if (name === RpcFunc.enterGame) {\n      const res = await this.checkTocken(data)\n      this.sendMessage(ws, name, res)\n    } else {\n      // TODO 和副本通信\n    }\n  }\n\n  sendMessage(ws: Webscoket, name: RpcFunc,res: any){\n    const headerBuffer = Buffer.alloc(1)\n    headerBuffer.writeUInt8(name)\n\n    const path = getProtoPathByRpcFunc(name, 'res')\n    const coder = protoRoot.lookup(path)\n    const dataBuffer = coder.encode(res).finish()\n\n    const buffer = Buffer.concat([headerBuffer, dataBuffer])\n    ws.send(buffer)\n  }\n\n  // checkTocken也需要改成promise\n  checkTocken({ token }: { token: string }) {\n    return new Promise((rs) => {\n      const client = new AuthClient('localhost:3333', grpc.credentials.createInsecure());\n      const req = new CheckTokenReq()\n      req.setToken(token);\n\n      client.checkToken(req, (err, message) => {\n        rs(message.toObject())\n      })\n    })\n  }\n```\n\n### client to server\n\n```ts\n  this.ws.onmessage = (e) => {\n    try {\n      const ta = new Uint8Array(e.data);\n      const name = ta[0];\n      const path = getProtoPathByRpcFunc(name, 'res')\n      const coder = protoRoot.lookup(path)\n      const data = coder.decode(ta.slice(1))\n      try {\n        if (this.maps.has(name) && this.maps.get(name).length) {\n          this.maps.get(name).forEach(({ cb, ctx }) => cb.call(ctx, data));\n        } else {\n          console.log(`no ${name} message or callback, maybe timeout`);\n        }\n      } catch (error) {\n        console.log(\"call error:\", error);\n      }\n    } catch (error) {\n      console.log(\"onmessage parse error:\", error);\n    }\n  };\n```\n在onmessage里面需要把typeArray转成数组\n\nsend里面同样需要改造一下\n\n```ts\n  async send(name: RpcFunc, data: IData) {\n    const path = getProtoPathByRpcFunc(name, 'req')\n    const coder = protoRoot.lookup(path)\n    const typeArrayData = coder.encode(data).finish()\n    const arraybufferData = new ArrayBuffer(typeArrayData.length + 1)\n    const view = new DataView(arraybufferData)\n    let index = 0\n    view.setUint8(index++, name)\n    for (let i = 0; i < typeArrayData.length; i++) {\n      view.setUint8(index++, typeArrayData[i])\n    }\n\n    this.ws.send(view.buffer)\n  }\n```\n\n"},{"title":"10.柏林噪声生成地图","tags":["game","cocos","game algorithms"],"categories":["game algorithms"],"author":"akko","excerpt":"\n> 摘要： 目前游戏的背景图和登录的背景图比较小，本身只是一个图片组成的图层，mmoact游戏需要多个玩家可以不断的探索游戏的边界进行冒险，所以有限的地图基本无法在开放世界中留住玩家，手动不断生成地","link":"/posts/cocos/12.%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0%E7%94%9F%E6%88%90%E5%9C%B0%E5%9B%BE","content":"\n> 摘要： 目前游戏的背景图和登录的背景图比较小，本身只是一个图片组成的图层，mmoact游戏需要多个玩家可以不断的探索游戏的边界进行冒险，所以有限的地图基本无法在开放世界中留住玩家，手动不断生成地图工作量又大又没有连贯性，此时游戏开发界常用的算法之一就是柏林噪声算法了。\n\n##\n![柏林噪声](./image-1.png)\n算法2个入参如果是连续的，那么出参也是连续的。根据这个特性，可以传入x和y,结果传进去然后再cocos里面渲染出灰度图来\n\n![alt text](./imgae.png)\n灰度图直接用来渲染地形有点丑，可以采用叠加的形式。\n\n## sinx\n在这里需要平滑的叠加图像，以高中数学学过的函数sinx作为例子\n正弦（sine），数学术语，是三角函数的一种，在直角三角形中，任意一锐角∠A的对边与斜边的比，叫作∠A的正弦，记作sinA（由英语sine一词简写得来），即sinA=∠A的对边/斜边。\n![alt text](./image-2.png)\n\n影响sinx的曲线的因素有2个，![alt text](./image-3.png)\n振幅决定纵向偏移幅度，频率决定横向波形次数\n因此，可以组合2个正弦函数来组成更好的波形图\n![alt text](./image-4.png)\n\n## 1*sin(1*x)\n\n![alt text](./image-5.png)\n以sinx为例，每次给振幅除以2，给频率乘以2,得到类似的压缩图像，然后再把这四组图像叠加就可以得到一个趋近于山体的图像\n然后再给灰度图每个区域上色，就可以得到类似的图片\n\n![alt text](./image-6.png)\n\n## 到此结束"}]
